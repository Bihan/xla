--- a/tensorflow/core/profiler/convert/xplane_to_tools_data.cc
+++ b/tensorflow/core/profiler/convert/xplane_to_tools_data.cc
@@ -23,6 +23,8 @@ limitations under the License.
 #include "tensorflow/core/platform/env.h"
 #include "tensorflow/core/platform/logging.h"
 #include "tensorflow/core/platform/protobuf.h"
+#include "tensorflow/core/profiler/convert/hlo_proto_to_graph_view.h"
+#include "tensorflow/core/profiler/convert/hlo_proto_to_memory_visualization_utils.h"
 #include "tensorflow/core/profiler/convert/hlo_to_tools_data.h"
 #include "tensorflow/core/profiler/convert/op_stats_to_input_pipeline_analysis.h"
 #include "tensorflow/core/profiler/convert/op_stats_to_op_profile.h"
@@ -53,6 +55,49 @@ namespace profiler {
 
 namespace {
 
+StatusOr<std::string> ConvertHloProtoToMemoryViewer(
+    const xla::HloProto& hlo_proto) {
+  static constexpr int kSmallBufferSize = 16 * 1024;  // 16KB
+  static constexpr int kMemorySpaceColor = 0;         // HBM
+
+  auto result_or = ConvertHloProtoToPreprocessResult(
+      hlo_proto, kSmallBufferSize,
+      GetHeapSimulatorTraceId(hlo_proto, kMemorySpaceColor), kMemorySpaceColor);
+  if (!result_or.ok()) {
+    return errors::Internal(
+        "Failed to convert HLO proto to memory viewer result: ",
+        result_or.status().message());
+  }
+
+  std::string json_output;
+  tensorflow::protobuf::util::JsonPrintOptions options;
+  options.always_print_primitive_fields = true;
+  auto encoded_status = tensorflow::protobuf::util::MessageToJsonString(
+      result_or.value(), &json_output, options);
+  if (!encoded_status.ok()) {
+    const auto& error_message = encoded_status.message();
+    return errors::Internal(
+        "Failed to convert memory viewer result to JSON format: ",
+        absl::string_view(error_message.data(), error_message.length()));
+  }
+
+  return json_output;
+}
+
+StatusOr<std::string> ConvertHloProtoToGraphViewer(
+    const xla::HloProto& hlo_proto, const ToolOptions& options) {
+  TF_ASSIGN_OR_RETURN(GraphViewerParams params,
+                      ParseGraphViewerParams(options));
+  if (params.type == "graph") {
+    return ConvertHloProtoToGraph(hlo_proto, params.node_name,
+                                  params.graph_width, params.render_options,
+                                  params.format);
+  } else {
+    return ConvertHloProtoToStringView(hlo_proto, params.verbose,
+                                       params.show_metadata);
+  }
+}
+
 std::pair<std::string, bool> ConvertXSpaceToTraceEvents(
     const std::vector<XSpace>& xspaces) {
   if (xspaces.size() != 1) {
@@ -232,7 +277,6 @@ std::pair<std::string, bool> ConvertMultiXSpacesToOpProfileViewer(
 
   return std::make_pair(profile.SerializeAsString(), true);
 }
-}  // namespace
 
 std::pair<std::string, bool> ConvertMultiXSpacesToToolData(
     const std::vector<XSpace>& xspaces,
@@ -278,5 +322,6 @@ std::pair<std::string, bool> ConvertMultiXSpacesToToolData(
   }
 }
 
+}  // namespace
 }  // namespace profiler
 }  // namespace tensorflow
--- a/tensorflow/core/platform/macros.h
+++ b/tensorflow/core/platform/macros.h
@@ -21,7 +21,7 @@ limitations under the License.
 // Compiler supports GCC-style attributes
 #define TF_ATTRIBUTE_NORETURN __attribute__((noreturn))
 #define TF_ATTRIBUTE_ALWAYS_INLINE __attribute__((always_inline))
-#define TF_ATTRIBUTE_NOINLINE __attribute__((noinline))
+#define TF_ATTRIBUTE_NOINLINE [[noinline]]
 #define TF_ATTRIBUTE_UNUSED __attribute__((unused))
 #define TF_ATTRIBUTE_COLD __attribute__((cold))
 #define TF_ATTRIBUTE_WEAK __attribute__((weak))
